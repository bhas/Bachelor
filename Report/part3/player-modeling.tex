\section{Learning to adapt to opponents}
\label{sec:part3}

In the previous chapter we created an algorithm to develop the default strategy for the APC. The default strategy is one of the two strategies that will be used to determine the actions of the APC. The other strategy is the adaptive strategy. \\

The goal of this chapter is to learn the APC to create an algorithm to develop the adaptive strategy by solving problem statement 3.

\vspace{4mm}
\begin{statementBox2}{Problem statement 3}
How can one further develop a strategy for a poker computer to be able to adapt to the playing style of the opponent?
\end{statementBox2}
\vspace{4mm} 

In poker there is no such thing as a single optimal strategy. Every strategy has weaknesses and therefore the optimal strategy is one that takes advantage of the weaknesses of the strategies of the opponents. In order to take advantage of the opponents strategies one must first understand their strategy. In poker understanding the opponents is one of the most important key elements of the game. 

Once one understand the strategy of the opponent one has to adapt oneself's strategy.

\subsection{Design}
In order to learn the strategy of the opponents we try to model the player using player modeling, see section \ref{sec:pm}. 

In this section we will start by introducing the concept of player modeling. We then design the player model we wish to use for the APC and finally implement it as a subsystem called the poker player model.


\subsubsection{Player modeling}
\label{sec:pm}
Player modeling is a loosely defined concept and may vary from one context to another. The concept of player modeling is to make a computational model of a player. This model includes game related attributes, such as play style and preferences, as well as non-game related attributes, such as cultural background, gender, and personality. All decisions of the player are ultimately made on the basis of these attributes. 

Player modeling is used to describe or predict the players decisions, reasoning and reactions. In the field of artificial intelligences the human player is the most used model for developing computer players. Understanding the reason behind every choice of a player will not only bring a better understanding of the player but also a better understanding of the game and its mechanics.

Since the player model can easily become extremely extensive one normally only includes the relevant attributes of the player.

\subsubsection{Design of the player model}
It is crucial to figure out which attributes are relevant to the specific player model. When trying to model a player there is almost no limit to what could be included. Attributes such as state of mind, energy, and distractions affect the decision of every human player.  

We listed the attributes that we find most relevant for poker.

\begin{description}
\item[Aggressiveness] How often does the player tend to bet or raise.
\item[Tightness] How strictly does the player's actions reflect the strength of the hand. For instance, a tight player will play aggressive when having a strong hand and defensive or fold when having a weak hand. A loose player may bluff (play aggressive having a weak hand) and slow play (play defensive having a strong hand) a lot.
\item[Riskiness] How easy is it to push the player to fold. Risky players tend to fold less often and are therefore harder to bluff.
\item[Body language] Most human players unconsciously show emotions through their body language. The professional poker players can tell a lot about a players hole cards solely by looking at their body language.
\item[Time of decision making] The time a player use for each decision can show the confidence of the players choice. A fast decisions indicates an easy decision. 
\end{description}

Since our APC is targeted towards computer players as well as human players, it makes no sense to use attributes such as body language and the time of decision making to model the opponents. Those attributes only affect human players. Instead we will model the opponents using the attributes aggressiveness, tightness, and riskiness.

Aggressiveness is easy to find simply by looking at the actions of the opponent. We choose to divide aggressiveness into three attributes. The first is overall aggressiveness and indicates the average aggressiveness of the player throughout the whole game. The second is recent aggressiveness which shows the aggressiveness within the recent five rounds. finally we have current aggressiveness which refers to the aggressiveness of the previous states of the current round. 
The reason we divide the aggressiveness into three attributes is to allow the system to register if the opponent changes strategy during the game. In such case the recent aggressiveness will differ significantly form the overall aggressiveness. 

Tightness is a bit more complicated as we need to know the hole cards of the player. We only track the tightness of rounds where the player make it to the showdown. We will then find the average tightness for all rounds.

Riskiness is relevant because it shows how beneficial it can be to play aggressive. Safe players is easier to force to fold by simply playing a bit more aggressive than usual by for instance bluffing. Likewise it is a lot more risky to bluff against a risky player.

\subsubsection{Implementation of the player model?}
To model each player we have created a subsystem called the poker player model (PPM). The PPM is responsible for tracking the aggressiveness, tightness, and riskiness.

A PPM object is created for each opponent and the PPM then tracks the attributes of the player if given the data from a round.

The aggressiveness is found as:

\[Aggressiveness = \frac{Action_{Agg}}{Action_{Total}}\]

Her $Action_{Agg}$ is the number of aggressive actions (bet or raise) and  $Action_{Total}$ is the total number of actions. This is found for every round. Overall-, recent-, and current aggressiveness is found as an average of all rounds, last five rounds, and current round respectively.





\subsection{Test}


\subsection{Discussion}

\subsection{Conclusion}
